
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
  <title>restfulvim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="restfulvim">
<meta property="og:url" content="https://nguyen-vm.github.io/index.html">
<meta property="og:site_name" content="restfulvim">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="restfulvim">
  
    <link rel="alternative" href="/atom.xml" title="restfulvim" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>
</html>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/myname"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">My Blog</a>
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">MyLogo</li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
      <a class="main-nav-link st-search-show-outputs">搜索</a>
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main">
  
    <article id="post-Java内存区域与内存溢出异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/03/Java内存区域与内存溢出异常/" class="article-date">
  <time datetime="2019-04-02T16:00:00.000Z" itemprop="datePublished">2019-04-03</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/Java内存区域与内存溢出异常/">Java内存区域与内存溢出异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h4><p>程序计数器是一块很小的内存空间，代表当前线程执行的字节码的行号指示器。<br>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。<br>为了线程切换后恢复到正常的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h4><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型。<br>每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。<br>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double），对象引用（reference类型，它不等同与对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
</ul>
<p>​    在单线程中，使用-Xss参数减少栈内存容量或者定义大量的本地变量，增大此方法帧中本地变量表的长度。结果将抛出StackOverflowError异常，异常出现时输出的堆栈深度响应缩小。</p>
<p><strong>虚拟机栈StackOverflowError异常</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM args: -Xss128k</span><br><span class="line"> */</span><br><span class="line">public class JavaVMStackSOF &#123;</span><br><span class="line"> 	private int stackLength = 1;</span><br><span class="line"> 	public void stackLeak() &#123;</span><br><span class="line"> 		stackLength++;</span><br><span class="line"> 		stackLeak();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	public static void main(String[] args) throws Throwable &#123;</span><br><span class="line"> 		JavaVmStackSOF sof = new JavaVmStackSOF();</span><br><span class="line"> 		try &#123;</span><br><span class="line"> 			sof.stackLeak();</span><br><span class="line"> 		&#125; catch (Throwable e) &#123;</span><br><span class="line"> 			System.out.println(&quot;stack length:&quot; + sof.stackLength);</span><br><span class="line"> 			throw e;			</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常。</li>
</ul>
<p>​    通过不断建立线程的方式会产生内存溢出异常，因为虚拟机栈是线程私有的，不断创建线程需要不断的分配虚拟机栈内存。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时越容易把剩下的内存耗尽。如果是建立过多的线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆（-Xmx）和减少栈容量（-Xss）来换取更多的线程。</p>
<p><strong>创建线程导致内存溢出异常</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM args: -Xms20m -Xmx 20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span><br><span class="line">public class JavaVMStackOOM &#123;</span><br><span class="line">    private void dontStop() &#123;</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stackLeakByThread() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread thread = new Thread(new Runable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        JavaVMStackOOM oom = new JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h4><p>虚拟机栈为Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。<br>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemory异常。</p>
<h4 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h4><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动是创建。<br>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都要在这里分配内存。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”（Garbage Collected Heap）。<br>Java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，就像我们的磁盘空间一样。<br>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。<br>如果再堆中没有内存进行实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<p>Java堆用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>
<p><strong>Java堆内存溢出异常测试</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM args: -Xms20m -Xmx 20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line"> 	static class OOMObject &#123;&#125;</span><br><span class="line"> 	public static void main(String[] args) &#123;</span><br><span class="line"> 		List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"> 		while (true) &#123;</span><br><span class="line"> 			list.add(new OOMObjects());</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h4><p>方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。<br>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等等。在此借助CGLib直接操作字节码运行时生成大量的动态类，填满方法区，使其内存溢出。</p>
<p><strong>借助CGLib使方法区出现内存溢出异常</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class="line"> */</span><br><span class="line">public class JavaMethodAreaOOM &#123;</span><br><span class="line">	static class OOMObject &#123;&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Enhancer enhancer = new Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(false);</span><br><span class="line">            enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">                    retuen proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h4><p>运行时常量池是方法区的一部分。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>字面量：文本字符串、声明为final的常量值等；<br>符号引用：类和接口的完全限定名、字段的名称和描述符、方法的名称和描述符</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期间可以将新的常量放入池中（String类的intern()方法）<br>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<p><strong>运行时常量池导致的内存溢出异常</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class="line"> */</span><br><span class="line">public class RuntimeConstantPoolOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	// 使用List保持着常量池引用，避免Full GC回收常量池行为</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        // 10M的PermSize在interger范围内足够产生OOM了</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(String.valuOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量池的好处：<br>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>1.节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>2.节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p>
<p>双等号==的含义：<br>基本数据类型之间应用双等号，比较的是他们的数值。<br>引用类型之间应用双等号，比较的是他们在内存中的存放地址。</p>
<p>关于常量池的扩展：<a href="https://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="noopener">https://www.jianshu.com/p/c7f47de2ee80</a></p>
<h4 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p><strong>使用Unsafe分配本机内存</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM args: -Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="line"> */</span><br><span class="line">public class DirectMemoryOOM &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(true);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(null);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="参考文献：《深入理解Java虚拟机》（第2版）周志明-著"><a href="#参考文献：《深入理解Java虚拟机》（第2版）周志明-著" class="headerlink" title="参考文献：《深入理解Java虚拟机》（第2版）周志明 著"></a>参考文献：《深入理解Java虚拟机》（第2版）周志明 著</h6>
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/03/Java内存区域与内存溢出异常/" data-id="cju0rw4f400006sw6h923jdku" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-Java内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/03/Java内存模型/" class="article-date">
  <time datetime="2019-04-02T16:00:00.000Z" itemprop="datePublished">2019-04-03</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/Java内存模型/">Java内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>​    Java虚拟机规范中试图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>​    Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p>
<p>​    Java内存模型规定了所有的变量都存储在主内存中（虚拟机内存的一部分）。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示。</p>
<p><img src="https://github.com/Nguyen-Vm/Nguyen-Vm.github.io/blob/master/img/jmm.jpg?raw=true" alt="img"></p>
<p>​    关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了以下8中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<p>1.lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态。</p>
<p>2.unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
<p>3.read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p>
<p>4.load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
<p>5.use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。</p>
<p>6.assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量。</p>
<p>7.store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p>
<p>8.write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中。</p>
<p>​    Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<p>1.不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</p>
<p>2.不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
<p>3.不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
<p>4.一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>5.一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
<p>6.如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
<p>7.如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p>
<p>8.对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store、write操作）。</p>
<h6 id="参考文献：《深入理解Java虚拟机》（第2版）周志明-著"><a href="#参考文献：《深入理解Java虚拟机》（第2版）周志明-著" class="headerlink" title="参考文献：《深入理解Java虚拟机》（第2版）周志明 著"></a>参考文献：《深入理解Java虚拟机》（第2版）周志明 著</h6>
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/03/Java内存模型/" data-id="cju0ynvo40000p8w6ershivpq" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-《高性能MySQL(第3版)》摘要——索引篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/《高性能MySQL(第3版)》摘要——索引篇/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/《高性能MySQL(第3版)》摘要——索引篇/">《高性能MySQL(第3版)》摘要——索引篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>简介</p>
<p>　　索引是存储引擎用于快速找到记录的一种数据结构。</p>
<p>　　索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。当数据量较少且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。</p>
<p>　　索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。</p>
<p>一、索引基础</p>
<p>　　MySQL的索引类似于书籍对应了页码的目录。</p>
<p>　　索引可以包含一个或多个列的值。如果索引包含多个列，name列的顺序也十分重要，因为MySQL只能高效的使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引的大不相同的。</p>
<p><strong>索引的类型</strong></p>
<p><strong>1.B-Tree索引</strong></p>
<p>​    当人们讨论索引的时候如果没有特别指明类型，那么多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。</p>
<p>　　B-Tree对索引列是顺序组织存储的，索引很适合查找范围数据。例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以I到K开头的名字”这样的查找效率是会常高。</p>
<p>假如有如下数据表：</p>
<p>　　CREATE TABLE people(</p>
<p>　　　　last_name　varchar(50)   not null,</p>
<p>　　　　first_naem　varchar(50)   not null,</p>
<p>　　　　dob　　　　date　　　　not null,</p>
<p>　　　　gender 　　 enum(‘m’,’f’)  not null,</p>
<p>　　　　key(last_name, first_naem, dob)</p>
<p>　　);</p>
<p>对于表中的每一行数据，索引中包含了last_name, first_name和dob列的值。</p>
<p>B-Tree索引适合于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。</p>
<p>WHERE条件中查询条件可任意顺序，MySQl的查询优化器会优化到匹配最佳索引。</p>
<p>前面所述的索引对如下类型的查询有效。</p>
<p>全值匹配：</p>
<p>　　select * from people where last_name = ‘Allen’ and first_name = ‘Cuba’ and dob = ‘1960-01-01’;</p>
<p>　　全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen、出生于1960-01-01的人。</p>
<p>匹配最左前缀：</p>
<p>　　select * from people where last_name = ‘Allen’;</p>
<p>　　前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。</p>
<p>匹配列前缀：</p>
<p>　　select * from people where last_name like ‘J%’;</p>
<p>　　也可以只匹配某一列的值得开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用了索引的第一列。</p>
<p>匹配范围值：</p>
<p>　　select * from people where last_name between ‘Allen’ and ‘Barrymore’;</p>
<p>　　例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</p>
<p>精确匹配某一列并范围匹配另外一列：</p>
<p>　　select * from people where last_name = ‘Allen’ and first_name like ‘K%’;</p>
<p>　　前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头的人。即第一列last_name全匹配，第二列first_name范围匹配。</p>
<p>只访问索引的查询：</p>
<p>　　select last_name, first_name from people where last_name = ‘Allen’ and first_name = ‘Cube’;</p>
<p>　　B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行（覆盖索引）。</p>
<p>因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果ORDER BY字句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于B-Trss索引的限制：</p>
<p>如果不是按照索引的最左列开始查找，则无法使用索引。</p>
<p>　　select * from people where first_name = ‘Bill’;</p>
<p>　　select * from people where dob = ‘xxxx-xx-xx’;</p>
<p>　　select * from people where last_name like ‘%X’;</p>
<p>　　例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。</p>
<p>不能跳过索引中的列。</p>
<p>　　select * from people where last_name = ‘Smith’ and dob = ‘xxxx-xx-xx’;（只能使用索引的第一列）</p>
<p>　　也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列。</p>
<p>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</p>
<p>　　select * from people where last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob = ‘1976-12-23’;</p>
<p>　　这个查询只能使用索引的前两列，因为这里LIKE是一个范围条件。如果范围查询列值得数量有限，那么可以通过使用多个等于条件来代替范围条件。</p>
<p>到这里读者应该可以明白，前面提到的索引列的顺序是多么重要：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<p><strong>2.哈希索引</strong></p>
<p><strong>3.空间数据索引（R-Tree）</strong></p>
<p><strong>4.全文索引</strong></p>
<p><strong>5.其他索引类别</strong></p>
<p>二、索引的优点</p>
<p>1.索引大大减少了服务器需要扫描的数据量。</p>
<p>2.索引可以帮助服务器避免排序和临时表。</p>
<p>3.索引可以将随机I/O变为顺序I/O。</p>
<p><strong>索引是最好的解决方案吗？</strong></p>
<p>索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录匹配。例如可以使用分区技术。如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来代替索引。</p>
<p>三、高性能的索引策略</p>
<p>1.独立的列</p>
<p>　　“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>　　反例：mysql&gt; SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</p>
<p>　　　　　mysql&gt; SELECT … WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(data_col) &lt;= 10;</p>
<p>　　我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。</p>
<p>2.前缀索引和索引选择性</p>
<p>　　字符列太长会让索引变得大且慢，通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>　　但这样会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数的比值。</p>
<p>　　索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>　　一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。</p>
<p>　　对于BLOB、TEXT或者更长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>　　诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。</p>
<p>　　创建前缀索引：mysql&gt; ALTER TABLE sakila.city ADD KEY(city(7));</p>
<p>3.多列索引</p>
<p>　　一个常见的错误就是，为每个列创建独立的索引，后者按照错误的顺序创建多列索引。</p>
<p>4.选择合适的索引列顺序</p>
<p>　　对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。但一定要记住别忘了WHERE字句中的排序、分组和范围条件等其他因素，这些因素可能对查询性能造成非常大的影响。</p>
<p>5.聚簇索引</p>
<p>6.覆盖索引</p>
<p>　　如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<p>7.使用索引扫描来做排序</p>
<p>　　只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用索引排序。</p>
<p>　　例如，Sakila示例数据库的表rental在列（retal_date, inventory_id,customer_id）上有名为rental_date的索引。</p>
<p>　　MySQL可以使用rental_date索引为下面的查询做排序，EXPLAIN中不会出现文件排序（firesort）操作；</p>
<p>　　mysql&gt; EXPLAIN SELECT rental_id, staff_id FROM rental WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id, customer_id\G;</p>
<p>　　即使ORDER BY子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p>
<p>　　mysql&gt; … WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id DESC;</p>
<p>　　第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀。</p>
<p>　　mysql&gt; … WHERE rental_date &gt; ‘2005-05-25’ ORDER BY rental_date, inventory_id;</p>
<p>　　上面这个查询也没问题，ORDER BY使用的两列就是索引的最左前缀。</p>
<p>反例，下面是一些不能使用索引做排序的查询：</p>
<ul>
<li>下面这个查询使用了两张不同的排序方向，但是索引列都是正序排序的：</li>
</ul>
<p>　　　　… WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id DESC, customer_id ASC;</p>
<ul>
<li>下面这个查询的ORDER BY子句中引用了一个不在索引的列：</li>
</ul>
<p>　　　　… WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id, staff_id;</p>
<ul>
<li>下面这个查询的WHERE和ORDER BY中的列无法组合成索引的最左前缀：</li>
</ul>
<p>　　　　… WHERE rental_date = ‘2005-05-25’ ORDER BY customer_id;</p>
<ul>
<li>下面这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：</li>
</ul>
<p>　　　　… WHERE rental_date &gt; ‘2005-05-25’ ORDER BY inventory_id, customer_id;</p>
<ul>
<li>这个查询在inventory_id列上有多个等于条件。对于排序来说，这也是一种范围查询：</li>
</ul>
<p>　　　　… WHERE rental_date = ‘2005-05-25’ AND inventory_id IN (1, 2) ORDER BY customer_id;</p>
<p>8.压缩（前缀压缩）索引</p>
<p>9.冗余和重复索引</p>
<p>　　重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>　　如果创建了索引（A,B），再创建（A）就是冗余索引，因为这只是前一个索引的前缀索引。因此前一个也可以当做后一个索引来使用。如果再创建（B,A）、（B），则不是冗余索引。</p>
<p>　　冗余索引通常发生在为表添加新索引的时候。例如，有人可能会增加一个新的索引（A,B）而不是扩展已有的索引（A），还有一种情况是将一个索引扩展为（A,ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<p>　　尽量扩展已有的索引而不是创建新索引。但有时候处于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。例如，如果再整数列上有一个索引，现在需要额外增加一个很长的VARCHAR列来扩展该索引，那性能可能会急剧下降。</p>
<p>10.未使用的索引</p>
<p>11.索引和锁</p>
<p>四、索引案例学习</p>
<p>　　假设要设计一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色，等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许根据用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。如何设计索引满足上面的复杂需求呢？</p>
<p>1.支持多种过滤条件</p>
<p>　　将大部分查询中都会用到的列作为组合索引的前缀，即使查询没有使用到该列，那么可以通过在查询条件中新增IN()列表(多个等值条件查询)查询条件来让MySQL选择该索引。这种做法在该列的选择性不高的时候非常有效，但如果列有太多不同的值，就会让IN()列表太长，这样做就不行了。</p>
<p>2.避免多个范围条件</p>
<p><img src="https://github.com/Nguyen-Vm/Nguyen-Vm.github.io/blob/master/img/range-condition.png?raw=true" alt="img"></p>
<p>假设我们有一个last_online列并希望通过下面的查询显示在过去几周上线过的用户：</p>
<p>　WHERE eye_color  IN (‘brown’, ‘blue’, ‘hezel’)</p>
<p>　　AND   hair_color  IN (‘black’, ‘red’, ‘blonde’, ‘brown’)</p>
<p>　　AND   sex            IN (‘M’, ‘F’)</p>
<p>　　ADN   last_online &gt; DATE_SUB(NOW(), INTERVAL 7 DAY)</p>
<p>　　ADN   age            BETWEEN 18 ADN 25</p>
<p>这个查询有一个问题：他有两个范围条件，last_online列和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用它们。</p>
<p>方法一：将age字段转换为一个IN()的列表；</p>
<p>方法二：实现计算好一个active列，由定时任务来维护，每当用户登录时，将对应值设置为1，并且将过去连续七天未曾登录的用户的值设置为0；</p>
<p>3.优化排序</p>
<p>　　使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上百万行的话会怎么样？例如如果WHERE子句只有sex列，如何排序；对于那些选择性非常低的列，可以增加一些特殊的索引来做排序。例如，可以创建（sex，rating）索引用于下面的查询：</p>
<p>　　mysql&gt; SELECT <cols> FROM profiles WHERE sex = ‘M’ ORDER BY rating LIMIT 10;</cols></p>
<p>这个查询使用了ORDER BY和LIMIT，如果没有索引的话会很慢。</p>
<p>即使有索引，如果用户界面上需要翻页，而且翻页翻到比较靠后时查询也可能非常慢。</p>
<p>　　mysql&gt; SELECT <cols> FROM profiles WHERE sex = ‘M’ ORDER BY rating LIMIT 1000000 10;</cols></p>
<p>无论如何创建索引，这种查询都是个严重的问题。因为随着偏移量的增加，MySQL需要花费大量的时间来扫描需要丢弃的数据。</p>
<p>　　优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获取需要的行。这可以减少MySQL扫描那些需要丢弃的行数。下面这个查询显示了如何高效地使用（sex，rating）索引进行排序和分页：</p>
<p>　　mysql&gt; SELECT <cols> FROM profiles INNER JOIN (SELECT <primary key cols> FROM profiles WHERE x.sex = ‘M’ ORDER BY rating LIMIT 1000000, 10) AS x USING(<primary key cols>);</primary></primary></cols></p>
<p>五、补充：</p>
<p>1.创建索引SQL：</p>
<p>　　CREATE INDEX index_name ON table_name(col[(length)]…);</p>
<p>　　ALTER TABLE table_name ADD INDEX index_name(col[(length)]…);</p>
<p>2.删除索引SQL：</p>
<p>　　DROP INDEX index_name ON table_name;</p>
<p>　　ALTER TABLE table_name DROP INDEX index_name;</p>
<p>3.走不走索引的总结（如有错误，欢迎指正）：</p>
<ul>
<li>NOT IN，&lt;&gt;，LIKE ‘%…’ 不走索引；</li>
<li>=，IN(多个等值条件查询)，LIKE ‘(非%开头)…’，BETWEEN … AND …(范围条件查询)，EXISTS，NOT EXISTS走索引；</li>
<li>&lt;，&lt;=，&gt;，&gt;=如果字段是整数类型会走索引；字符类型根据实际查询速度来判断；如果全盘扫描速度比索引速度要快则不走索引；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/《高性能MySQL(第3版)》摘要——索引篇/" data-id="cjtxr1ocl000074w6nilad0qt" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-使用HttpURLConnection发送GET，POST请求" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/使用HttpURLConnection发送GET，POST请求/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/使用HttpURLConnection发送GET，POST请求/">使用HttpURLConnection发送GET，POST请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>接口项目地址：<a href="https://github.com/Nguyen-Vm/s-program" target="_blank" rel="noopener">https://github.com/Nguyen-Vm/s-program</a></p>
<p>API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/area&quot;)</span><br><span class="line">public class AreaController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AreaService areaService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)</span><br><span class="line">    private Map&lt;String, Object&gt; listArea()&#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Area&gt; areaList = areaService.getAreaList();</span><br><span class="line">        modelMap.put(&quot;list&quot;, areaList);</span><br><span class="line">        return modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/insert&quot;, method = RequestMethod.POST)</span><br><span class="line">    private Map&lt;String, Object&gt; insertArea(@RequestBody Area area)&#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = new HashMap&lt;&gt;();</span><br><span class="line">        boolean result = areaService.addArea(area);</span><br><span class="line">        modelMap.put(&quot;result&quot;, result);</span><br><span class="line">        return modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送GET请求代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        // 获取本地IP</span><br><span class="line">        String hostName = inetAddress.getHostAddress();</span><br><span class="line"></span><br><span class="line">        String getUrlStr = String.format(&quot;http://%s:%s/s-program/area/list&quot;, hostName, 8080);</span><br><span class="line">        get(getUrlStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void get(String urlStr) throws IOException &#123;</span><br><span class="line">        URL url = new URL(urlStr);</span><br><span class="line"></span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        // 返回结果-字节输入流转换成字符输入流，控制台输出字符</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            sb.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送POST请求代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        // 获取本地IP</span><br><span class="line">        String hostName = inetAddress.getHostAddress();</span><br><span class="line"></span><br><span class="line">        String postUrlStr = String.format(&quot;http://%s:%s/s-program/area/insert&quot;, hostName, 8080);</span><br><span class="line">        post(postUrlStr, &quot;&#123;\&quot;areaName\&quot;: \&quot;中国上海\&quot;, \&quot;priority\&quot;: 1&#125;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void post(String urlStr, String body) throws IOException &#123;</span><br><span class="line">        URL url = new URL(urlStr);</span><br><span class="line"></span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">        // 设置Content-Type</span><br><span class="line">        connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;);</span><br><span class="line">        // 设置是否向httpUrlConnection输出，post请求设置为true，默认是false</span><br><span class="line">        connection.setDoOutput(true);</span><br><span class="line"></span><br><span class="line">        // 设置RequestBody</span><br><span class="line">        PrintWriter printWriter = new PrintWriter(connection.getOutputStream());</span><br><span class="line">        printWriter.write(body);</span><br><span class="line">        printWriter.flush();</span><br><span class="line"></span><br><span class="line">        // 返回结果-字节输入流转换成字符输入流，控制台输出字符</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            sb.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/使用HttpURLConnection发送GET，POST请求/" data-id="cjtxr9xui0000csw6b0tdvngo" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-查询某年某月一个月的数据，以日历的形式展示" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/查询某年某月一个月的数据，以日历的形式展示/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/查询某年某月一个月的数据，以日历的形式展示/">查询某年某月一个月的数据，以日历的形式展示</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>市场上有些这样的应用，会展示某年某月一个月的数据，比如女神们经常用的“大姨妈”APP，一些游戏的用户签到信息，等等</p>
<p><img src="https://github.com/Nguyen-Vm/Nguyen-Vm.github.io/blob/master/img/dayima.png?raw=true" alt="img"></p>
<p>那我们在写后台接口的时候，就需要返回这一个月的数据，今天我就分享一下笔者经常在工作中使用的方法。</p>
<p>数据库DB中存了许多用户的应用数据，每条数据有一个日期字段，可以是Integer类型(yyyyMMdd)，可以是String类型(yyyy-MM-dd)，还可以是Date类型.</p>
<p>首先定义了一个这样的类来保存某天的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CalendarDate&lt;T&gt;&#123;</span><br><span class="line">    public Integer day;</span><br><span class="line"></span><br><span class="line">    public Integer weekDay;</span><br><span class="line"></span><br><span class="line">    public Boolean isToday;</span><br><span class="line"></span><br><span class="line">    public T info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个字段的意思分别是：day-这个月的第几天，weekDay-星期几，isToday-是否是今天，info-该天的用户数据。</p>
<p>请求接口如下，请求需要年和月两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/calendar&quot;)</span><br><span class="line">public List&lt;CalendarDate&lt;List&lt;String&gt;&gt;&gt; calendarDates(@RequestParam Integer year, @RequestParam Integer month) &#123;</span><br><span class="line">    Function&lt;String, Optional&lt;List&lt;String&gt;&gt;&gt; function = day -&gt; &#123;</span><br><span class="line">        List&lt;String&gt; datas = new ArrayList&lt;&gt;();</span><br><span class="line">        datas.add(day); // DB: datas = tableMapper.findByDay(day);</span><br><span class="line">        return Optional.of(datas);</span><br><span class="line">    &#125;;</span><br><span class="line">    return DateUtils.calendar(year, month, function);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点就是下面封装好的工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtils &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;CalendarDate&lt;T&gt;&gt; calendar(int year, int month, Function&lt;String, Optional&lt;T&gt;&gt; function) &#123;</span><br><span class="line">        List&lt;CalendarDate&lt;T&gt;&gt; cdList = new ArrayList&lt;&gt;();</span><br><span class="line">        int monthDays = monthDays(year, month);</span><br><span class="line">        CalendarDate&lt;T&gt; cdR;</span><br><span class="line">        for (int day = 1; day &lt;= monthDays; day++) &#123;</span><br><span class="line">            cdR = new CalendarDate&lt;&gt;();</span><br><span class="line">            cdR.day = day;</span><br><span class="line">            LocalDate date = LocalDate.of(year, month, day);</span><br><span class="line">            cdR.weekDay = dayOfWeek(date);</span><br><span class="line">            cdR.isToday = isToday(date);</span><br><span class="line">            if (function != null) &#123;</span><br><span class="line">                Optional&lt;T&gt; optional = function.apply(date.toString());</span><br><span class="line">                if (optional.isPresent()) &#123;</span><br><span class="line">                    cdR.info = optional.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cdList.add(cdR);</span><br><span class="line">        &#125;</span><br><span class="line">        return cdList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isToday(LocalDate date) &#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        return date.getYear() == today.getYear() &amp;&amp;</span><br><span class="line">                date.getMonth() == today.getMonth() &amp;&amp;</span><br><span class="line">                date.getDayOfMonth() == today.getDayOfMonth();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dayOfWeek(LocalDate date) &#123;</span><br><span class="line">        return null == date ? 0 : date.getDayOfWeek().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int monthDays(int year, int month) &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.YEAR, year);</span><br><span class="line">        calendar.set(Calendar.MONTH, month - 1);</span><br><span class="line">        calendar.set(Calendar.DATE, 1);</span><br><span class="line">        calendar.roll(Calendar.DATE, -1);</span><br><span class="line">        return calendar.get(Calendar.DATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对不同的业务要求，编写不一样的function函数，就可以返回日历形式的用户数据了。</p>
<p>项目地址如下：<a href="https://github.com/cnblogs-projects/cnblogs-calendar" target="_blank" rel="noopener">https://github.com/cnblogs-projects/cnblogs-calendar</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/查询某年某月一个月的数据，以日历的形式展示/" data-id="cjtxrq8kv0000dsw6qvobgi5f" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-EntityManager常用方法简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/EntityManager常用方法简介/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/EntityManager常用方法简介/">EntityManager常用方法简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>首先简单介绍一下Entity生命周期中的Managed，Detached，Removed三种状态变化过程，如下图所示：</p>
<p><img src="https://github.com/Nguyen-Vm/Nguyen-Vm.github.io/blob/master/img/entity-manager.jpg?raw=true" alt="img"></p>
<p>1.entityManager.persist(Object entity);　　新增数据；</p>
<p>如果entity的主键不为空，而数据库没有该主键，会抛出异常；</p>
<p>如果entity的主键不为空，而数据库有该主键，且entity的其他字段与数据库不同，persist后不会更新数据库；</p>
<p>2.entityManager.find(Class<t> entityClass, Object primaryKey);　　根据主键查找数据；</t></p>
<p>如果主键格式不正确，会抛出illegalArgumentException异常;</p>
<p>如果主键在数据库未找到数据返回null；</p>
<p>3.entityManager.remove(Object entity);　　删除数据；</p>
<p>只能将Managed状态的Entity实例删除，由此Entity实例状态变为Removed；</p>
<p>4.entityManager.merge(T entity);　　</p>
<p>将 Detached状态的Entity实例转至Managed状态；</p>
<p>5.entityManager.clear();</p>
<p>将所有的Entity实例状态转至Detached状态；</p>
<p>6.entityManager.flush();</p>
<p>将所有Managed状态的Entity实例同步到数据库；</p>
<p>7.entityManager.refresh(Object entity);</p>
<p>加载Entity实例后，数据库该条数据被修改，refresh该实例，能得到数据库最新的修改，覆盖原来的Entity实例；</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EntityManager/">EntityManager</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/EntityManager常用方法简介/" data-id="cjtxs8zg90000gsw6b6ncirau" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-MySQL-数据合并" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/MySQL-数据合并/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/MySQL-数据合并/">MySQL-数据合并</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>原数据：</p>
<table>
<thead>
<tr>
<th style="text-align:left">name type money</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">jack 月薪 10000</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">jack 年终奖 3000</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">lisa 月薪 20000</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">lisa 年终奖 3500</td>
<td></td>
</tr>
</tbody>
</table>
<p>期望数据：</p>
<table>
<thead>
<tr>
<th>name salary reword</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>jack 120000 3000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lisa 240000 3500</td>
<td></td>
</tr>
</tbody>
</table>
<p>sql语句：</p>
<p>INSERT INTO emp(name, salary, reword) </p>
<p>​    SELECT</p>
<p>​        name,</p>
<p>​        GROUP_CONCAT(CASE WHEN type = ‘月薪’ THEN money*12 END),</p>
<p>​        GROUP_CONCAT(CASE WHEN type = ‘年终奖’ THEN money END)</p>
<p>​    FRPM emp</p>
<p>​    GROUP BY name;</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/MySQL-数据合并/" data-id="cjtxs8zgi0001gsw61d2db63h" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-微信公众号开发——用户账号体系" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/微信公众号开发——用户账号体系/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/微信公众号开发——用户账号体系/">微信公众号开发——用户账号体系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>不管什么应用，用户账号体系都可以设置两张表，一张系统用户表，一张真实信息表；</p>
<p>用户表有OPEN_ID字段，真实信息表有手机号字段。</p>
<p>用户进入系统，生成一条用户数据；用户验证手机号后，生成一条真实信息数据；这条真实信息数据关联了那条用户数据；</p>
<p>没有关联真实信息的用户，称为游客；关联了真实信息的用户，称为注册用户。</p>
<p>公众号菜单入口进行微信网页授权获取用户的OPEN_ID，并将其保存在COOKIE中；用户验证完手机号后，将手机号也存进COOKIE；</p>
<p>微信授权后，有OPEN_ID：</p>
<p>　　先从COOKIE中获取手机号，得到空串或者手机号：</p>
<p>　　　　手机号查询真实查询真实信息:　</p>
<p>　　　　　　找到真实信息，真实信息查询用户数据：</p>
<p>　　　　　　　　找到用户数据，赋值OPEN_ID；——老用户授权，完善或覆盖OPEN_ID。</p>
<p>　　　　　　　　没找到用户数据，添加有OPEN_ID，真实信息主键ID的用户数据；——手机号没有关联系统用户，基本不会出现。</p>
<p>　　　　　　没找到真实信息，OPEN_ID查询用户数据:</p>
<p>　　　　　　　　没有找到，添加有OPEN_ID的用户数据，称之为游客；找打了，就不添加。——游客，也有可能是COOKIE-PHONE失效，之后会删除。</p>
<p>验证手机号，有手机号：</p>
<p>　　通过手机号查询真实信息，有则返回真实信息主键ID，没有添加有手机号的真实信息数据，返回主键ID；</p>
<p>　　从COOKIE中获取OPEN_ID，得到空串或OPEN_ID：</p>
<p>　　　　真实信息主键ID查询用户数据：</p>
<p>　　　　　　没有找到用户数据：</p>
<p>　　　　　　　　如果OPEN_ID是空串，初始化一条用户数据；关联手机号，返回验签；——COOKIE中没有OPEN_ID的游客注册</p>
<p>　　　　　　　　OPEN_ID不是空串，用该OPEN_ID去数据库找到该用户数据；关联手机号，返回验签；——游客注册</p>
<p>　　　　　　找到用户数据，删除所有该OPEN_ID下，真实信息为NULL的用户数据；如果用户数据OPNE_ID为空，赋值OPEN_ID，保存用户数据，返回验签。——老用户登录</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信公众号/">微信公众号</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/微信公众号开发——用户账号体系/" data-id="cjtxs8zgr0003gsw6bxcy8d58" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-基于EntityManager的分页查询解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/04/01/基于EntityManager的分页查询解决方案/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/基于EntityManager的分页查询解决方案/">基于EntityManager的分页查询解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>需求：分页查询学生信息</p>
<p>项目环境：Spring Boot 2.0.6.RELEASE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>Maven依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>分页查询返回体类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class IPagination&lt;T&gt; &#123;</span><br><span class="line">    /** 当前页数 **/</span><br><span class="line">    private int pager;</span><br><span class="line">    /** 总页数 **/</span><br><span class="line">    private int pages;</span><br><span class="line">    /** 每页条数 **/</span><br><span class="line">    private int size;</span><br><span class="line">    /** 总条数 **/</span><br><span class="line">    private long total;</span><br><span class="line">    /** 忽略数据条数 **/</span><br><span class="line">    private int offset;</span><br><span class="line">    /** 列表数据 **/</span><br><span class="line">    private List&lt;T&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public IPagination() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IPagination(int pager, int size) &#123;</span><br><span class="line">        if (pager &gt;= 1 &amp;&amp; size &gt;= 1) &#123;</span><br><span class="line">            this.pager = pager;</span><br><span class="line">            this.size = size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invalid pager: &quot; + pager + &quot; or size: &quot; + size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IPagination create(int pager, int size) &#123;</span><br><span class="line">        return new IPagination(pager, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotal(long total) &#123;</span><br><span class="line">        this.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;T&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPager() &#123;</span><br><span class="line">        return pager == 0 ? 1 : pager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getOffset() &#123;</span><br><span class="line">        return size * (getPager() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPages() &#123;</span><br><span class="line">        return Double.valueOf(Math.ceil((double) total / (double) size)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getTotal() &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/student&quot;)</span><br><span class="line">public class StudentApiController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/search&quot;)</span><br><span class="line">    public IPagination&lt;StudentResponse&gt; search(@RequestBody StudentSearchRequest request) &#123;</span><br><span class="line">        return studentService.search(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就一个简单的POST请求，请求体有页数、每页条数、查询参数等属性。</p>
<p>Service层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PaginationMapper paginationMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询学生信息</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public IPagination&lt;StudentResponse&gt; search(StudentSearchRequest request) &#123;</span><br><span class="line">        // 拼接SQL语句</span><br><span class="line">        StringBuilder sql = new StringBuilder(&quot;SELECT id, name FROM t_galidun_student &quot;);</span><br><span class="line">        // 查询需要的参数，先存进Map</span><br><span class="line">        Map&lt;String, Object&gt; maps = new HashMap&lt;&gt;();</span><br><span class="line">        if (request.name != null) &#123;</span><br><span class="line">            sql.append(&quot;WHERE name LIKE :name&quot;);</span><br><span class="line">            maps.put(&quot;name&quot;, &quot;%&quot; + request.name + &quot;%&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用通用方法返回查询结果</span><br><span class="line">        return paginationMapper.nativeSearch(request.nowPage, request.pageSize, sql.toString(), maps, StudentResponse.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一层主要是拼接sql，提供查询需要的参数，最后调用通用方法返回结果。</p>
<p>Mapper层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PaginationMapper &#123;</span><br><span class="line"></span><br><span class="line">    @PersistenceContext</span><br><span class="line">    private EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询通用方法</span><br><span class="line">     *</span><br><span class="line">     * @param nowPage  当前页</span><br><span class="line">     * @param pageSize 每页条数</span><br><span class="line">     * @param sql      sql语句</span><br><span class="line">     * @param maps     sql查询参数</span><br><span class="line">     * @param clazz    返回类型</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; IPagination&lt;T&gt; search(Integer nowPage, Integer pageSize, String sql, Map&lt;String, Object&gt; maps, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        // 初始化分页返回体</span><br><span class="line">        IPagination pagination = IPagination.create(nowPage, pageSize);</span><br><span class="line">        // 查询结果总条数</span><br><span class="line">        int total = getQueryWithParameters(entityManager.createNativeQuery(sql), maps).getResultList().size();</span><br><span class="line">        pagination.setTotal(total);</span><br><span class="line">        if (total == 0) return pagination;</span><br><span class="line">        Query query = getQueryWithParameters(entityManager.createNativeQuery(sql), maps);</span><br><span class="line">        // 忽略指定条数据，返回一页数据</span><br><span class="line">        query.setFirstResult(pagination.getOffset()).setMaxResults(pagination.getSize());</span><br><span class="line">        // 指定返回对象类型</span><br><span class="line">        query.unwrap(NativeQueryImpl.class).setResultTransformer(Transformers.aliasToBean(clazz));</span><br><span class="line">        // 列表数据</span><br><span class="line">        pagination.setList(query.getResultList());</span><br><span class="line">        return pagination;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置查询所需的参数</span><br><span class="line">     *</span><br><span class="line">     * @param query</span><br><span class="line">     * @param maps</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Query getQueryWithParameters(Query query, Map&lt;String, Object&gt; maps) &#123;</span><br><span class="line">        if (maps.size() &gt; 0) &#123;</span><br><span class="line">            for (String key : maps.keySet()) &#123;</span><br><span class="line">                query.setParameter(key, maps.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个通用的方法，只需要传入查询的页数，每页数据条数，sql语句，查询参数，返回体类型即可。</p>
<p>每个Query只能调用一次getResultList方法，调用之后再次调用就会抛异常，所以方法中有两处entityManager.createNaticeQuery(sql)，一次是为了查询总条数，另一次是查询当前页的数据。</p>
<p>查询总条数的时候可以改为使用COUNT（主键或者非NULL索引）；读者有其他能提高查询性能的方法，方便的话，分享一下吧。</p>
<p>项目地址：<a href="https://github.com/Nguyen-Vm/entity-manager" target="_blank" rel="noopener">https://github.com/Nguyen-Vm/entity-manager</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EntityManager/">EntityManager</a></li></ul>

        <a data-url="https://nguyen-vm.github.io/2019/04/01/基于EntityManager的分页查询解决方案/" data-id="cjtxs8zgv0005gsw6eojhcqjk" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/03/Java内存区域与内存溢出异常/">Java内存区域与内存溢出异常</a>
          </li>
        
          <li>
            <a href="/2019/04/03/Java内存模型/">Java内存模型</a>
          </li>
        
          <li>
            <a href="/2019/04/01/《高性能MySQL(第3版)》摘要——索引篇/">《高性能MySQL(第3版)》摘要——索引篇</a>
          </li>
        
          <li>
            <a href="/2019/04/01/使用HttpURLConnection发送GET，POST请求/">使用HttpURLConnection发送GET，POST请求</a>
          </li>
        
          <li>
            <a href="/2019/04/01/查询某年某月一个月的数据，以日历的形式展示/">查询某年某月一个月的数据，以日历的形式展示</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EntityManager/">EntityManager</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信公众号/">微信公众号</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 restfulvim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">搜索</a>
</nav>

  

<!-- totop start -->
<div id="totop">
	<a title="返回顶部"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
